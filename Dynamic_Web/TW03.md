# TW2

### **Firebase 数据持久化 | Firebase Data Persistence**

1. **Firebase 数据持久化的重要性 | Importance of Firebase Data Persistence**  
   - **中文**：通过 Firebase，可以将用户数据（例如晚餐计划）保存在云端，即使刷新应用、关闭浏览器或更换设备也不会丢失数据。  
   - **English**: Firebase allows you to save user data (e.g., dinner plans) in the cloud, preventing data loss even when the app is refreshed, the browser is closed, or the device is changed.  
   - **中文**：Firebase 支持离线模式，类似 Google Drive，用户重新上线时会与云端同步。  
   - **English**: Firebase supports offline mode, similar to Google Drive, and synchronizes with the cloud when the user goes back online.

---

2. **Firebase 配置与设置 | Firebase Setup and Configuration**  
   - **中文**：实验教程中详细说明了设置方法。配置完成后，可以通过 JavaScript 获取数据库的引用对象。  
   - **English**: The setup process is detailed in the lab guide. Once configured, you can get database references in JavaScript.  
   - **中文**：可以通过 `ref(db, "path")` 获取数据库路径引用，并使用 `child()` 获取子路径引用。  
   - **English**: You can create references using `ref(db, "path")` and retrieve sub-path references with `child()`.

---

3. **主要操作方法 | Key Operations**  
   - **中文**：
     - **`set()`**：将对象保存到 Firebase 中。
     - **`get()`**：从 Firebase 中获取数据，返回一个快照，通过 `snapshot.val()` 提取数据。
     - **`push()`**：创建带唯一键的对象，防止用户间数据冲突（如多人同时发布博客）。  
   - **English**:
     - **`set()`**: Saves an object to Firebase.
     - **`get()`**: Retrieves data from Firebase, returning a snapshot. The data can be accessed via `snapshot.val()`.
     - **`push()`**: Creates an object with a unique key to prevent data conflicts between users (e.g., multiple users posting blogs simultaneously).

---

4. **模型转换与数据保存 | Model Conversion and Persistence**  
   - **中文**：模型不能直接保存，需通过 `modelToPersistence()` 转换，过滤掉非必要属性并规范路径。  
   - **English**: Models cannot be saved directly. Use `modelToPersistence()` to convert them, filter unnecessary properties, and standardize paths.  
   - **中文**：读取时使用 `persistenceToModel()`，解决 ID 和默认值等问题。  
   - **English**: Use `persistenceToModel()` during retrieval to resolve issues like IDs and default values.
   - modelToPersistence 和 persistenceToModel 是与 Firebase 无关的函数（不调用 Firebase 的 API），它们负责将模型转换为可持久化存储的格式，以及从存储格式转换回模型的格式。可以参考讲座材料了解为什么持久化数据的格式与模型的格式略有不同。需要注意的是，persistenceToModel 返回一个 Promise，因为它需要获取菜品信息（dishes）。
   - **modelToPersistence and persistenceToModel** are firebase-independent functions (do not call Firebase APIs). They transform the model into a format that can be persisted and convert it back. Refer to the lecture material to understand why persisted data has a slightly different format than the model. Note that persistenceToModel returns a promise because it needs to retrieve the dishes.
   - **saveToFirebase 和 readFromFirebase** 调用上述转换函数，然后调用 Firebase 的 API 将转换后的数据写入或从云端读取。
   - saveToFirebase and readFromFirebase call the above transformers and then use Firebase APIs to write/read the transformed data to/from the cloud.
   - **connectToFirebase** 负责最初读取模型，并确保每次模型发生变化时，都将模型保存到 Firebase。
   - connectToFirebase initially reads the model and ensures that the model is saved to Firebase every time it changes.
   - 为了使应用程序数据（模型）实现持久化存储，我们在应用启动时调用 connectToFirebase()。
   - To make the app data (model) persistent, we call connectToFirebase() during app bootstrapping.

---

1. **实时同步功能 | Real-Time Synchronization**  
   - **中文**：使用 `onValue()` 订阅 Firebase 数据的变化，实现实时更新功能，例如多窗口间数据同步。  
   - **English**: Use `onValue()` to subscribe to Firebase data changes for real-time updates, such as synchronizing data across multiple windows.  
   - **中文**：可结合 `childAdded()` 和 `childRemoved()` 监听子对象的增删事件，从而优化性能。  
   - **English**: Combine with `childAdded()` and `childRemoved()` to monitor addition or removal of sub-objects, improving performance.


---

### **Reactive Objects 和 Side Effects**

**原文**  
Reactive objects can call your ACB (Action Callback) when they change, and you can select which changes are relevant for your side effect using a lighter `checkACB`. This allows for flexible reactivity and automation.

**中文**  
响应式对象在数据发生变化时可以调用你的 ACB（动作回调）。通过一个轻量的 `checkACB`，你可以筛选出哪些变化与你的副作用相关，从而实现灵活的反应性和自动化。

---

### **副作用的概念 | The Concept of Side Effects**

**原文**  
Side effects are actions triggered by changes in reactive objects. For example:
- Resolving a promise when the current dish ID changes.
- Persisting the model to the cloud when the model changes (e.g., number of guests, dishes).

**中文**  
副作用是由响应式对象的变化触发的操作，例如：
- 当当前菜品 ID 改变时，触发一个 Promise 的解析。
- 当模型变化（如客人数、菜品）时，将模型持久化到云端。

---

### **注册副作用 | Registering Side Effects**

**原文**  
Side effects are registered using reactive model technologies like `MobX` and `Vue`. The general form is:
```javascript
watchOrReaction(checkACB, sideEffectACB);
```
- `checkACB`: Checks if the change is relevant, returning the parts of the object that matter.
- `sideEffectACB`: Runs the side effect when `checkACB` detects relevant changes.

**中文**  
使用响应式模型技术（如 `MobX` 和 `Vue`）注册副作用，形式为：
```javascript
watchOrReaction(checkACB, sideEffectACB);
```
- `checkACB`：检查变化是否相关，返回对象中重要的部分。
- `sideEffectACB`：当 `checkACB` 检测到相关变化时，执行副作用操作。

---

### **单参数版本 | Single ACB Versions**

**原文**  
MobX's `autorun` and Vue's `watchEffect` allow simpler registration:
```javascript
autorun(sideEffectACB);
```
The callback automatically tracks and reacts to relevant changes.

**中文**  
MobX 的 `autorun` 和 Vue 的 `watchEffect` 提供了更简单的注册方式：
```javascript
autorun(sideEffectACB);
```
回调会自动跟踪并响应相关变化。

---

### **避免副作用循环 | Avoid Infinite Loops in Side Effects**

**原文**  
If your side effect changes the data being checked by `checkACB`, it may re-trigger itself, causing an infinite loop.

**中文**  
如果副作用操作修改了 `checkACB` 检查的数据，会重新触发自己，可能导致无限循环。

---

### **在 Redux 和 Recoil 中的副作用 | Side Effects in Redux and Recoil**

#### Redux
**原文**  
Redux provides `listener middleware` to attach side effects to specific actions. Alternatively, you can write custom middleware.

**中文**  
Redux 提供了 `listener middleware`，可以将副作用绑定到特定的动作。也可以编写自定义中间件实现。

#### Recoil
**原文**  
Recoil supports side effects via `atom effects`, allowing you to perform actions whenever an atom changes.

**中文**  
Recoil 支持通过 `atom effects` 实现副作用，可在 atom 数据变化时执行特定操作。

---

### **总结 | Summary**

**原文**  
Side effects enable powerful reactive behaviors. By carefully designing `checkACB` and avoiding feedback loops, you can create responsive and stable applications.

**中文**  
副作用提供了强大的响应式行为。通过精心设计 `checkACB` 并避免反馈循环，可以创建响应性强且稳定的应用程序。
